# AwesomeFigures

## Задача 1

> Напишите на C# библиотеку для поставки внешним клиентам, которая умеет вычислять площадь круга по радиусу и треугольника по трем сторонам.

### Дополнительно к работоспособности:

- [x] Юнит-тесты - `xUnit` + `FlientAssertions` + `Moq`
- [x] Легкость добавления других фигур - pattern `Visitor` + иерархия интерфейсов
- [x] Вычисление площади фигуры без знания типа фигуры в compile-time - pattern `Visitor`
- [x] Проверку на то, является ли треугольник прямоугольным - _просто есть)_


### Запуск

> Как такового `.exe` нету, но на всякий)

```bash
dotnet restore
dotnet build
dotnet test
```

## Задача 2

> В базе данных MS SQL Server есть продукты и категории. Одному продукту может соответствовать много категорий, в одной категории может быть много продуктов. Напишите SQL запрос для выбора всех пар «Имя продукта – Имя категории». Если у продукта нет категорий, то его имя все равно должно выводиться.

```sql
select
    product.Name as 'Product Name',
    category.Name as 'Category Name',
    count(*) as 'Duplicates'
from Production.Product as product
    left join Production.ProductSubcategory as sub
    on product.ProductSubcategoryID = sub.ProductSubcategoryID
        left join Production.ProductCategory as category
        on sub.ProductCategoryID = category.ProductCategoryID
group by product.Name, category.Name
```

### Пояснительная записка :)

1. Для выполнения условия _"Если у продукта нет категорий, то его имя все равно должно выводиться."_ использован `left join`. Он выводит все элементы из левой таблицы, вне зависимости от того, нашлась ли ему "пара" в правой таблице.

2. В связи с _"Одному продукту может соответствовать много категорий, в одной категории может быть много продуктов."_ я решил использовать `group by` для того, чтобы предотвратить **потенциальные** дубликаты в итоговой выборке вида _«Имя продукта – Имя категории»_.
Понятно, что `group by` сильно влияет на производительность, но данный момент не уточнялся, и я решил перестраховаться :)

3. Двойной джоин использован по той причине, что я делал запрос на реальной базе **MS AdventureWorks**, и у них вот такая структура получения категории для продукта - надеюсь, не притично).
Ну и понятно, что два раза использовался именно `left join`, тк если бы вторым был использован обычный `join`, то мы бы потеряли элементы из таблицы продуктов, к которым из "правых" таблиц нет "пар".

_P.S. кусок из итоговой выборки_
![a](https://user-images.githubusercontent.com/82240296/191619565-5d46647f-436c-42e0-9af9-153cbec84ed1.png)

_P.P.S. в `MS AdventureWorks` имя продукта является уникальным индексом, поэтому тут все продукты `IN (0, 1)` категорий и повторений нету :(._
